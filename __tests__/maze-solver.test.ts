import { MazeGenerator } from '../maze-generator';
import { MazeSolver } from '../maze-solver';
import type { Cell } from '../types';

describe('MazeSolver', () => {
  it('should find the shortest path in a simple solvable maze', async () => {
    // 一個簡單的 1x3 迷宮: S - M - E
    const grid: Cell[][] = [
      [
        { x: 0, y: 0, walls: { top: true, right: false, bottom: true, left: true }, visited: false }, // S
        { x: 1, y: 0, walls: { top: true, right: false, bottom: true, left: false }, visited: false }, // M
        { x: 2, y: 0, walls: { top: true, right: true, bottom: true, left: false }, visited: false },  // E
      ]
    ];

    const solver = new MazeSolver(grid);
    const path = await solver.solve({ x: 0, y: 0 }, { x: 2, y: 0 });
    
    // 路徑應為 [(0,0), (1,0), (2,0)]
    expect(path.length).toBe(3);
    expect(path.map(c => c.x)).toEqual([0, 1, 2]);
    expect(path[0]).toBe(grid[0][0]);
    expect(path[1]).toBe(grid[0][1]);
    expect(path[2]).toBe(grid[0][2]);
  });

  it('should return an empty array for an unsolvable maze', async () => {
    // 一個完全封閉的 2x2 迷宮
    const unsolvableGrid: Cell[][] = [
      [
        { x: 0, y: 0, walls: { top: true, right: true, bottom: true, left: true }, visited: false },
        { x: 1, y: 0, walls: { top: true, right: true, bottom: true, left: true }, visited: false },
      ],
      [
        { x: 0, y: 1, walls: { top: true, right: true, bottom: true, left: true }, visited: false },
        { x: 1, y: 1, walls: { top: true, right: true, bottom: true, left: true }, visited: false },
      ],
    ];
    const solver = new MazeSolver(unsolvableGrid);
    const path = await solver.solve({ x: 0, y: 0 }, { x: 1, y: 1 });
    expect(path).toEqual([]);
  });

  it('should return a path of length 1 if start and end are the same', async () => {
    const grid = await new MazeGenerator(2, 2).generate();
    const solver = new MazeSolver(grid);
    const path = await solver.solve({ x: 0, y: 0 }, { x: 0, y: 0 });
    expect(path.length).toBe(1);
    expect(path[0]).toBe(grid[0][0]);
  });

  it('should solve any maze generated by MazeGenerator', async () => {
    // 這是一個整合測試
    const generator = new MazeGenerator(10, 10, 'kruskal', { seed: 99 });
    const grid = await generator.generate();
    
    const start = { x: 0, y: 0 };
    const end = { x: 9, y: 9 };

    const solver = new MazeSolver(grid);
    const path = await solver.solve(start, end);

    // 因為我們所有的生成演算法都會產生「完美」迷宮（所有儲存格都相連），
    // 所以一定能找到路徑。
    expect(path.length).toBeGreaterThan(0);
    expect(path[0]).toBe(grid[start.y][start.x]);
    expect(path[path.length - 1]).toBe(grid[end.y][end.x]);
  });

  it('should call the onStep callback during solving', async () => {
    const onStepMock = jest.fn();
    const grid = await new MazeGenerator(5, 5, 'kruskal').generate();
    const solver = new MazeSolver(grid, { onStep: onStepMock });
    await solver.solve({ x: 0, y: 0 }, { x: 4, y: 4 });
    expect(onStepMock.mock.calls.length).toBeGreaterThan(0);
  });
});