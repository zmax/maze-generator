"use strict";(()=>{function g(c,t){let e=c.x-t.x,s=c.y-t.y;switch(e){case 1:c.walls.left=!1,t.walls.right=!1;break;case-1:c.walls.right=!1,t.walls.left=!1;break}switch(s){case 1:c.walls.top=!1,t.walls.bottom=!1;break;case-1:c.walls.bottom=!1,t.walls.top=!1;break}}function b(c,t,e,s){let i=[],{x:r,y:n}=c,a=[{dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}];for(let{dx:o,dy:l}of a){let h=r+o,d=n+l;h>=0&&h<e&&d>=0&&d<s&&i.push(t[d][h])}return i}function B(c,t,e,s){return b(c,t,e,s).filter(i=>!i.visited)}function E(c){return function(){var t=c+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}}var S=class{parent=new Map;rank=new Map;constructor(t=[]){t.forEach(e=>this.makeSet(e))}makeSet(t){this.parent.has(t)||(this.parent.set(t,t),this.rank.set(t,0))}find(t){let e=this.parent.get(t);if(e===t)return t;let s=this.find(e);return this.parent.set(t,s),s}union(t,e){let s=this.find(t),i=this.find(e);if(s!==i){let r=this.rank.get(s),n=this.rank.get(i);r<n?this.parent.set(s,i):r>n?this.parent.set(i,s):(this.parent.set(i,s),this.rank.set(s,r+1))}}connected(t,e){return this.find(t)===this.find(e)}};var C=class{width;height;grid=[];stack=[];algorithm;random;options;constructor(t,e,s="recursive-backtracker",i={}){if(t<=0||e<=0)throw new Error("Width and height must be greater than 0.");if(this.width=t,this.height=e,this.algorithm=s,this.options={growingTreeStrategy:"random",straightBias:.75,binaryTreeBias:"north-west",...i},typeof this.options.straightBias=="number"&&(this.options.straightBias<0||this.options.straightBias>1))throw new Error("straightBias option must be between 0.0 and 1.0.");typeof this.options.seed=="number"?this.random=E(this.options.seed):this.random=Math.random}async generate(){if(this.algorithm==="recursive-division")return this.initializeOpenGrid(),await this.generateWithRecursiveDivision();switch(this.initializeGrid(),this.algorithm){case"prim":return await this.generateWithPrim();case"kruskal":return await this.generateWithKruskal();case"wilson":return await this.generateWithWilson();case"growing-tree":return await this.generateWithGrowingTree();case"binary-tree":return await this.generateWithBinaryTree();case"aldous-broder":return await this.generateWithAldousBroder();case"sidewinder":return await this.generateWithSidewinder();case"recursive-backtracker":case"recursive-backtracker-biased":default:return await this.generateWithRecursiveBacktracker()}}async generateWithRecursiveBacktracker(){let t=this.grid[0][0];t.visited=!0,this.stack.push(t);let e=this.options.onStep;for(;this.stack.length>0;){let s=this.stack[this.stack.length-1],i=B(s,this.grid,this.width,this.height);if(e&&await e({grid:this.grid,stack:[...this.stack],currentCell:s}),i.length>0){let r;if(this.algorithm==="recursive-backtracker-biased"){let n=this.stack.length>1?this.stack[this.stack.length-2]:null,a;if(n){let l=s.x-n.x,h=s.y-n.y;a=i.find(d=>d.x-s.x===l&&d.y-s.y===h)}let o=this.options.straightBias;a&&this.random()<o?r=a:r=i[Math.floor(this.random()*i.length)]}else r=i[Math.floor(this.random()*i.length)];g(s,r),r.visited=!0,this.stack.push(r)}else this.stack.pop(),e&&await e({grid:this.grid,stack:[...this.stack]})}return this.grid}async generateWithPrim(){let t=this.grid[Math.floor(this.random()*this.height)][Math.floor(this.random()*this.width)];t.visited=!0;let e=this.options.onStep,s=[],i=r=>{let{x:n,y:a}=r;a>0&&s.push({from:r,to:this.grid[a-1][n]}),n<this.width-1&&s.push({from:r,to:this.grid[a][n+1]}),a<this.height-1&&s.push({from:r,to:this.grid[a+1][n]}),n>0&&s.push({from:r,to:this.grid[a][n-1]})};for(i(t);s.length>0;){let r=Math.floor(this.random()*s.length),{from:n,to:a}=s.splice(r,1)[0];a.visited||(e&&await e({grid:this.grid,currentCell:a,activeSet:[n]}),g(n,a),a.visited=!0,i(a))}return this.grid}async generateWithKruskal(){let t=[];for(let i=0;i<this.height;i++)for(let r=0;r<this.width;r++)i<this.height-1&&t.push({c1:this.grid[i][r],c2:this.grid[i+1][r]}),r<this.width-1&&t.push({c1:this.grid[i][r],c2:this.grid[i][r+1]});for(let i=t.length-1;i>0;i--){let r=Math.floor(this.random()*(i+1));[t[i],t[r]]=[t[r],t[i]]}let e=new S(this.grid.flat()),s=this.options.onStep;for(let i of t){let{c1:r,c2:n}=i;e.connected(r,n)||(e.union(r,n),g(r,n),s&&await s({grid:this.grid,activeSet:[r,n]}))}return this.grid}async generateWithWilson(){let t=this.grid[Math.floor(this.random()*this.height)][Math.floor(this.random()*this.width)];t.visited=!0;let e=this.options.onStep,s=this.grid.flat().filter(i=>!i.visited);for(let i=s.length-1;i>0;i--){let r=Math.floor(this.random()*(i+1));[s[i],s[r]]=[s[r],s[i]]}for(let i of s){if(i.visited)continue;let r=[i],n=i;for(;!n.visited;){let a=b(n,this.grid,this.width,this.height),o=a[Math.floor(this.random()*a.length)],l=r.indexOf(o);l!==-1?r=r.slice(0,l+1):r.push(o),n=o,e&&await e({grid:this.grid,walkPath:[...r],currentCell:n})}for(let a=0;a<r.length-1;a++)g(r[a],r[a+1]),r[a].visited=!0,e&&await e({grid:this.grid,activeSet:[r[a],r[a+1]]})}return this.grid}async generateWithGrowingTree(){let t=[],e=this.grid[Math.floor(this.random()*this.height)][Math.floor(this.random()*this.width)];e.visited=!0,t.push(e);let s=this.options.onStep;for(;t.length>0;){let i=this.options.growingTreeStrategy,r;switch(i){case"newest":r=t.length-1;break;case"oldest":r=0;break;case"random":default:r=Math.floor(this.random()*t.length);break}let n=t[r],a=B(n,this.grid,this.width,this.height);if(s&&await s({grid:this.grid,activeSet:[...t],currentCell:n}),a.length>0){let o=a[Math.floor(this.random()*a.length)];g(n,o),o.visited=!0,t.push(o)}else t.splice(r,1)}return this.grid}async generateWithBinaryTree(){let t=this.options.binaryTreeBias,e=t.includes("north"),s=t.includes("south"),i=t.includes("west"),r=t.includes("east"),n=this.options.onStep;for(let a of this.grid)for(let o of a){let l=[];if(e&&o.y>0&&l.push(this.grid[o.y-1][o.x]),s&&o.y<this.height-1&&l.push(this.grid[o.y+1][o.x]),i&&o.x>0&&l.push(this.grid[o.y][o.x-1]),r&&o.x<this.width-1&&l.push(this.grid[o.y][o.x+1]),l.length>0){let h=l[Math.floor(this.random()*l.length)];g(o,h),n&&await n({grid:this.grid,currentCell:o,activeSet:[h]})}}return this.grid}async generateWithAldousBroder(){let t=this.grid[Math.floor(this.random()*this.height)][Math.floor(this.random()*this.width)];t.visited=!0;let e=this.width*this.height-1,s=this.options.onStep;for(;e>0;){let i=b(t,this.grid,this.width,this.height),r=i[Math.floor(this.random()*i.length)];r.visited||(g(t,r),r.visited=!0,e--),t=r,s&&await s({grid:this.grid,currentCell:t})}return this.grid}async generateWithSidewinder(){let t=this.options.onStep;for(let e=0;e<this.height;e++){let s=[];for(let i=0;i<this.width;i++){let r=this.grid[e][i];s.push(r);let n=i===this.width-1,a=e===0;if(n||!a&&this.random()<.5){let l=s[Math.floor(this.random()*s.length)];if(!a){let h=this.grid[l.y-1][l.x];g(l,h)}t&&await t({grid:this.grid,activeSet:[...s],currentCell:l}),s=[]}else{let l=this.grid[e][i+1];g(r,l),t&&await t({grid:this.grid,activeSet:[...s,l]})}}}return this.grid}async generateWithRecursiveDivision(){return await this.divide(0,0,this.width,this.height),this.grid}async divide(t,e,s,i){let r=this.options.onStep;if(s<2||i<2)return;if(s<i||s===i&&this.random()<.5){let a=e+Math.floor(this.random()*(i-1)),o=t+Math.floor(this.random()*s),l=[];for(let h=t;h<t+s;h++)h!==o&&(this.grid[a][h].walls.bottom=!0,this.grid[a+1][h].walls.top=!0,l.push(this.grid[a][h]));r&&await r({grid:this.grid,activeSet:l}),await this.divide(t,e,s,a-e+1),await this.divide(t,a+1,s,i-(a-e+1))}else{let a=t+Math.floor(this.random()*(s-1)),o=e+Math.floor(this.random()*i),l=[];for(let h=e;h<e+i;h++)h!==o&&(this.grid[h][a].walls.right=!0,this.grid[h][a+1].walls.left=!0,l.push(this.grid[h][a]));r&&await r({grid:this.grid,activeSet:l}),await this.divide(t,e,a-t+1,i),await this.divide(a+1,e,s-(a-t+1),i)}}initializeGrid(){this.stack=[],this.grid=Array.from({length:this.height},(t,e)=>Array.from({length:this.width},(s,i)=>({x:i,y:e,walls:{top:!0,right:!0,bottom:!0,left:!0},visited:!1})))}initializeOpenGrid(){this.stack=[],this.grid=Array.from({length:this.height},(t,e)=>Array.from({length:this.width},(s,i)=>({x:i,y:e,walls:{top:e===0,right:i===this.width-1,bottom:e===this.height-1,left:i===0},visited:!1})))}};var w=class{heap=[];insert(t,e){this.heap.push({item:t,priority:e}),this.siftUp(this.heap.length-1)}extractMin(){if(this.isEmpty())return null;this.swap(0,this.heap.length-1);let{item:t}=this.heap.pop();return this.isEmpty()||this.siftDown(0),t}isEmpty(){return this.heap.length===0}getItems(){return this.heap.map(t=>t.item)}getParentIndex(t){return Math.floor((t-1)/2)}getLeftChildIndex(t){return 2*t+1}getRightChildIndex(t){return 2*t+2}swap(t,e){[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]]}siftUp(t){let e=this.getParentIndex(t);for(;t>0&&this.heap[t].priority<this.heap[e].priority;)this.swap(t,e),t=e,e=this.getParentIndex(t)}siftDown(t){let e=t,s=this.getLeftChildIndex(t),i=this.getRightChildIndex(t),r=this.heap.length;s<r&&this.heap[s].priority<this.heap[e].priority&&(e=s),i<r&&this.heap[i].priority<this.heap[e].priority&&(e=i),t!==e&&(this.swap(t,e),this.siftDown(e))}};var y=class{grid;width;height;options;constructor(t,e={}){this.grid=t,this.height=t.length,this.width=this.height>0?t[0].length:0,this.options=e}heuristic(t,e){return Math.abs(t.x-e.x)+Math.abs(t.y-e.y)}async solve(t,e){return this.solveBidirectional(t,e)}async solveBidirectional(t,e){let s=this.grid[t.y][t.x],i=this.grid[e.y][e.x];if(s===i)return[s];let r=this.options.onStep,n=new w,a=new Set,o=new Map,l=new Map;l.set(s,0),n.insert(s,this.heuristic(s,i));let h=new w,d=new Set,v=new Map,x=new Map;x.set(i,0),h.insert(i,this.heuristic(i,s));let f=null;for(;!n.isEmpty()&&!h.isEmpty();){let u=n.extractMin();if(a.has(u))continue;if(a.add(u),d.has(u)){f=u;break}r&&await r({grid:this.grid,openSetForward:n.getItems(),closedSetForward:Array.from(a),openSetBackward:h.getItems(),closedSetBackward:Array.from(d),currentForward:u}),this._expandNeighbors(u,i,l,o,n);let m=h.extractMin();if(!d.has(m)){if(d.add(m),a.has(m)){f=m;break}r&&await r({grid:this.grid,openSetForward:n.getItems(),closedSetForward:Array.from(a),openSetBackward:h.getItems(),closedSetBackward:Array.from(d),currentForward:u,currentBackward:m}),this._expandNeighbors(m,s,x,v,h)}}if(f){let u=this._reconstructPath(o,f),m=this._reconstructPath(v,f);return m.reverse(),r&&await r({grid:this.grid,openSetForward:[],closedSetForward:Array.from(a),openSetBackward:[],closedSetBackward:Array.from(d),meetingNode:f}),u.concat(m.slice(1))}return[]}_expandNeighbors(t,e,s,i,r){let{x:n,y:a,walls:o}=t,l=[];!o.top&&a>0&&l.push(this.grid[a-1][n]),!o.right&&n<this.width-1&&l.push(this.grid[a][n+1]),!o.bottom&&a<this.height-1&&l.push(this.grid[a+1][n]),!o.left&&n>0&&l.push(this.grid[a][n-1]);for(let h of l){let d=(s.get(t)??1/0)+1;if(d<(s.get(h)??1/0)){i.set(h,t),s.set(h,d);let v=d+this.heuristic(h,e);r.insert(h,v)}}}_reconstructPath(t,e){let s=[e],i=e;for(;i=t.get(i);)s.unshift(i);return s}};var p={background:"#FFFFFF",wall:"#333333",path:"#81C784",current:"#FFEB3B",stack:"#90CAF9",activeSet:"#FFCC80",walkPath:"#CE93D8",forwardOpen:"#C8E6C9",forwardClosed:"#FFCDD2",backwardOpen:"#BBDEFB",backwardClosed:"#FFECB3",meetingNode:"#F48FB1"},k=class{ctx;mazeWidth;mazeHeight;cellSize;wallThickness;constructor(t,e,s){this.ctx=t.getContext("2d"),this.mazeWidth=e,this.mazeHeight=s;let i=t.width,r=t.height;this.cellSize=Math.floor(Math.min(i/e,r/s)),this.wallThickness=Math.max(1,Math.floor(this.cellSize/10))}clearCanvas(){this.ctx.fillStyle=p.background,this.ctx.fillRect(0,0,this.mazeWidth*this.cellSize,this.mazeHeight*this.cellSize)}drawCell(t,e){this.ctx.fillStyle=e,this.ctx.fillRect(t.x*this.cellSize,t.y*this.cellSize,this.cellSize,this.cellSize)}drawGrid(t){this.ctx.strokeStyle=p.wall,this.ctx.lineWidth=this.wallThickness,this.ctx.beginPath();for(let e=0;e<this.mazeHeight;e++)for(let s=0;s<this.mazeWidth;s++){let i=t[e][s],r=s*this.cellSize,n=e*this.cellSize;i.walls.top&&(this.ctx.moveTo(r,n),this.ctx.lineTo(r+this.cellSize,n)),i.walls.right&&(this.ctx.moveTo(r+this.cellSize,n),this.ctx.lineTo(r+this.cellSize,n+this.cellSize)),i.walls.bottom&&(this.ctx.moveTo(r+this.cellSize,n+this.cellSize),this.ctx.lineTo(r,n+this.cellSize)),i.walls.left&&(this.ctx.moveTo(r,n+this.cellSize),this.ctx.lineTo(r,n))}this.ctx.stroke()}renderStep(t){this.clearCanvas(),"closedSetForward"in t?(t.closedSetBackward.forEach(e=>this.drawCell(e,p.backwardClosed)),t.closedSetForward.forEach(e=>this.drawCell(e,p.forwardClosed)),t.openSetBackward.forEach(e=>this.drawCell(e,p.backwardOpen)),t.openSetForward.forEach(e=>this.drawCell(e,p.forwardOpen)),t.meetingNode&&this.drawCell(t.meetingNode,p.meetingNode)):(t.activeSet&&t.activeSet.forEach(e=>this.drawCell(e,p.activeSet)),t.stack&&t.stack.forEach(e=>this.drawCell(e,p.stack)),t.walkPath&&t.walkPath.forEach(e=>this.drawCell(e,p.walkPath)),t.currentCell&&this.drawCell(t.currentCell,p.current)),this.drawGrid(t.grid)}drawFinalPath(t,e){this.clearCanvas(),this.drawGrid(t),e.forEach(s=>this.drawCell(s,p.path)),this.drawGrid(t)}resizeCanvas(t){let e=t.parentElement,s=Math.min(e.clientWidth,e.clientHeight);t.width=s,t.height=s,this.cellSize=Math.floor(Math.min(t.width/this.mazeWidth,t.height/this.mazeHeight)),this.wallThickness=Math.max(1,Math.floor(this.cellSize/10))}};var M=class{canvas;drawer=null;currentGrid=null;isAnimating=!1;stopAnimationFlag=!1;algoSelect;widthInput;heightInput;seedInput;delayInput;generateBtn;solveBtn;stopBtn;rbBiasOption;rbBiasInput;gtStrategyOption;gtStrategySelect;btBiasOption;btBiasSelect;constructor(){this.canvas=document.getElementById("maze-canvas"),this.algoSelect=document.getElementById("algo-select"),this.widthInput=document.getElementById("width-input"),this.heightInput=document.getElementById("height-input"),this.seedInput=document.getElementById("seed-input"),this.delayInput=document.getElementById("delay-input"),this.generateBtn=document.getElementById("generate-btn"),this.solveBtn=document.getElementById("solve-btn"),this.stopBtn=document.getElementById("stop-btn"),this.rbBiasOption=document.getElementById("rb-bias-option"),this.rbBiasInput=document.getElementById("rb-bias-input"),this.gtStrategyOption=document.getElementById("gt-strategy-option"),this.gtStrategySelect=document.getElementById("gt-strategy-select"),this.btBiasOption=document.getElementById("bt-bias-option"),this.btBiasSelect=document.getElementById("bt-bias-select"),this.populateSelects(),this.bindEvents()}populateSelects(){["recursive-backtracker","recursive-backtracker-biased","prim","kruskal","wilson","growing-tree","binary-tree","aldous-broder","sidewinder","recursive-division"].forEach(i=>{let r=document.createElement("option");r.value=i,r.textContent=i.split("-").map(n=>n.charAt(0).toUpperCase()+n.slice(1)).join(" "),this.algoSelect.appendChild(r)}),["newest","random","oldest"].forEach(i=>this.gtStrategySelect.add(new Option(i,i))),["north-west","north-east","south-west","south-east"].forEach(i=>this.btBiasSelect.add(new Option(i,i)))}bindEvents(){this.generateBtn.addEventListener("click",()=>this.runGeneration()),this.solveBtn.addEventListener("click",()=>this.runSolver()),this.stopBtn.addEventListener("click",()=>{this.stopAnimationFlag=!0}),this.algoSelect.addEventListener("change",()=>this.toggleOptionsPanel()),window.addEventListener("resize",()=>this.handleResize()),this.toggleOptionsPanel()}toggleOptionsPanel(){let t=this.algoSelect.value;this.rbBiasOption.classList.toggle("hidden",t!=="recursive-backtracker-biased"),this.gtStrategyOption.classList.toggle("hidden",t!=="growing-tree"),this.btBiasOption.classList.toggle("hidden",t!=="binary-tree")}handleResize(){this.drawer&&(this.drawer.resizeCanvas(this.canvas),this.currentGrid&&this.drawer.drawFinalPath(this.currentGrid,[]))}setUiState(t){this.isAnimating=t,this.generateBtn.disabled=t,this.solveBtn.disabled=t||!this.currentGrid,this.stopBtn.disabled=!t}getOptions(){let e={seed:this.seedInput.value?parseInt(this.seedInput.value,10):void 0};switch(this.algoSelect.value){case"recursive-backtracker-biased":e.straightBias=parseFloat(this.rbBiasInput.value);break;case"growing-tree":e.growingTreeStrategy=this.gtStrategySelect.value;break;case"binary-tree":e.binaryTreeBias=this.btBiasSelect.value;break}return e}async runGeneration(){if(this.isAnimating)return;this.setUiState(!0),this.stopAnimationFlag=!1;let t=parseInt(this.widthInput.value,10),e=parseInt(this.heightInput.value,10),s=this.algoSelect.value,i=this.getOptions(),r=parseInt(this.delayInput.value,10);this.drawer=new k(this.canvas,t,e),this.drawer.resizeCanvas(this.canvas);let n=async o=>{if(this.stopAnimationFlag)throw new Error("Animation stopped by user.");this.drawer.renderStep(o),await new Promise(l=>setTimeout(l,r))},a=new C(t,e,s,{...i,onStep:n});try{this.currentGrid=await a.generate(),this.drawer.drawFinalPath(this.currentGrid,[])}catch(o){console.log(o)}finally{this.setUiState(!1)}}async runSolver(){if(this.isAnimating||!this.currentGrid)return;this.setUiState(!0),this.stopAnimationFlag=!1;let t=parseInt(this.delayInput.value,10),e={x:0,y:0},s={x:this.currentGrid[0].length-1,y:this.currentGrid.length-1},i=async n=>{if(this.stopAnimationFlag)throw new Error("Animation stopped by user.");this.drawer.renderStep(n),await new Promise(a=>setTimeout(a,t))},r=new y(this.currentGrid,{onStep:i});try{let n=await r.solve(e,s);this.drawer.drawFinalPath(this.currentGrid,n)}catch(n){console.log(n)}finally{this.setUiState(!1)}}};new M;})();
