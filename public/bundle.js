"use strict";(()=>{function m(c,t){let e=c.x-t.x,r=c.y-t.y;switch(e){case 1:c.walls.left=!1,t.walls.right=!1;break;case-1:c.walls.right=!1,t.walls.left=!1;break}switch(r){case 1:c.walls.top=!1,t.walls.bottom=!1;break;case-1:c.walls.bottom=!1,t.walls.top=!1;break}}function b(c,t,e,r){let i=[],{x:s,y:n}=c,a=[{dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}];for(let{dx:o,dy:l}of a){let h=s+o,d=n+l;h>=0&&h<e&&d>=0&&d<r&&i.push(t[d][h])}return i}function B(c,t,e,r){return b(c,t,e,r).filter(i=>!i.visited)}function E(c){return function(){var t=c+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}}var S=class{parent=new Map;rank=new Map;constructor(t=[]){t.forEach(e=>this.makeSet(e))}makeSet(t){this.parent.has(t)||(this.parent.set(t,t),this.rank.set(t,0))}find(t){let e=this.parent.get(t);if(e===t)return t;let r=this.find(e);return this.parent.set(t,r),r}union(t,e){let r=this.find(t),i=this.find(e);if(r!==i){let s=this.rank.get(r),n=this.rank.get(i);s<n?this.parent.set(r,i):s>n?this.parent.set(i,r):(this.parent.set(i,r),this.rank.set(r,s+1))}}connected(t,e){return this.find(t)===this.find(e)}};var y=class{width;height;grid=[];stack=[];algorithm;random;options;constructor(t,e,r="recursive-backtracker",i={}){if(t<=0||e<=0)throw new Error("Width and height must be greater than 0.");if(this.width=t,this.height=e,this.algorithm=r,this.options={growingTreeStrategy:"random",straightBias:.75,binaryTreeBias:"north-west",...i},typeof this.options.straightBias=="number"&&(this.options.straightBias<0||this.options.straightBias>1))throw new Error("straightBias option must be between 0.0 and 1.0.");typeof this.options.seed=="number"?this.random=E(this.options.seed):this.random=Math.random}async generate(){switch(this.initializeGrid(),this.algorithm){case"prim":return await this.generateWithPrim();case"kruskal":return await this.generateWithKruskal();case"wilson":return await this.generateWithWilson();case"growing-tree":return await this.generateWithGrowingTree();case"binary-tree":return await this.generateWithBinaryTree();case"aldous-broder":return await this.generateWithAldousBroder();case"recursive-backtracker":case"recursive-backtracker-biased":default:return await this.generateWithRecursiveBacktracker()}}async generateWithRecursiveBacktracker(){let t=this.grid[0][0];t.visited=!0,this.stack.push(t);let e=this.options.onStep;for(;this.stack.length>0;){let r=this.stack[this.stack.length-1],i=B(r,this.grid,this.width,this.height);if(e&&await e({grid:this.grid,stack:[...this.stack],currentCell:r}),i.length>0){let s;if(this.algorithm==="recursive-backtracker-biased"){let n=this.stack.length>1?this.stack[this.stack.length-2]:null,a;if(n){let l=r.x-n.x,h=r.y-n.y;a=i.find(d=>d.x-r.x===l&&d.y-r.y===h)}let o=this.options.straightBias;a&&this.random()<o?s=a:s=i[Math.floor(this.random()*i.length)]}else s=i[Math.floor(this.random()*i.length)];m(r,s),s.visited=!0,this.stack.push(s)}else this.stack.pop(),e&&await e({grid:this.grid,stack:[...this.stack]})}return this.grid}async generateWithPrim(){let t=this.grid[Math.floor(this.random()*this.height)][Math.floor(this.random()*this.width)];t.visited=!0;let e=this.options.onStep,r=[],i=s=>{let{x:n,y:a}=s;a>0&&r.push({from:s,to:this.grid[a-1][n]}),n<this.width-1&&r.push({from:s,to:this.grid[a][n+1]}),a<this.height-1&&r.push({from:s,to:this.grid[a+1][n]}),n>0&&r.push({from:s,to:this.grid[a][n-1]})};for(i(t);r.length>0;){let s=Math.floor(this.random()*r.length),{from:n,to:a}=r.splice(s,1)[0];a.visited||(e&&await e({grid:this.grid,currentCell:a,activeSet:[n]}),m(n,a),a.visited=!0,i(a))}return this.grid}async generateWithKruskal(){let t=[];for(let i=0;i<this.height;i++)for(let s=0;s<this.width;s++)i<this.height-1&&t.push({c1:this.grid[i][s],c2:this.grid[i+1][s]}),s<this.width-1&&t.push({c1:this.grid[i][s],c2:this.grid[i][s+1]});for(let i=t.length-1;i>0;i--){let s=Math.floor(this.random()*(i+1));[t[i],t[s]]=[t[s],t[i]]}let e=new S(this.grid.flat()),r=this.options.onStep;for(let i of t){let{c1:s,c2:n}=i;e.connected(s,n)||(e.union(s,n),m(s,n),r&&await r({grid:this.grid,activeSet:[s,n]}))}return this.grid}async generateWithWilson(){let t=this.grid[Math.floor(this.random()*this.height)][Math.floor(this.random()*this.width)];t.visited=!0;let e=this.options.onStep,r=this.grid.flat().filter(i=>!i.visited);for(let i=r.length-1;i>0;i--){let s=Math.floor(this.random()*(i+1));[r[i],r[s]]=[r[s],r[i]]}for(let i of r){if(i.visited)continue;let s=[i],n=i;for(;!n.visited;){let a=b(n,this.grid,this.width,this.height),o=a[Math.floor(this.random()*a.length)],l=s.indexOf(o);l!==-1?s=s.slice(0,l+1):s.push(o),n=o,e&&await e({grid:this.grid,walkPath:[...s],currentCell:n})}for(let a=0;a<s.length-1;a++)m(s[a],s[a+1]),s[a].visited=!0,e&&await e({grid:this.grid,activeSet:[s[a],s[a+1]]})}return this.grid}async generateWithGrowingTree(){let t=[],e=this.grid[Math.floor(this.random()*this.height)][Math.floor(this.random()*this.width)];e.visited=!0,t.push(e);let r=this.options.onStep;for(;t.length>0;){let i=this.options.growingTreeStrategy,s;switch(i){case"newest":s=t.length-1;break;case"oldest":s=0;break;case"random":default:s=Math.floor(this.random()*t.length);break}let n=t[s],a=B(n,this.grid,this.width,this.height);if(r&&await r({grid:this.grid,activeSet:[...t],currentCell:n}),a.length>0){let o=a[Math.floor(this.random()*a.length)];m(n,o),o.visited=!0,t.push(o)}else t.splice(s,1)}return this.grid}async generateWithBinaryTree(){let t=this.options.binaryTreeBias,e=t.includes("north"),r=t.includes("south"),i=t.includes("west"),s=t.includes("east"),n=this.options.onStep;for(let a of this.grid)for(let o of a){let l=[];if(e&&o.y>0&&l.push(this.grid[o.y-1][o.x]),r&&o.y<this.height-1&&l.push(this.grid[o.y+1][o.x]),i&&o.x>0&&l.push(this.grid[o.y][o.x-1]),s&&o.x<this.width-1&&l.push(this.grid[o.y][o.x+1]),l.length>0){let h=l[Math.floor(this.random()*l.length)];m(o,h),n&&await n({grid:this.grid,currentCell:o,activeSet:[h]})}}return this.grid}async generateWithAldousBroder(){let t=this.grid[Math.floor(this.random()*this.height)][Math.floor(this.random()*this.width)];t.visited=!0;let e=this.width*this.height-1,r=this.options.onStep;for(;e>0;){let i=b(t,this.grid,this.width,this.height),s=i[Math.floor(this.random()*i.length)];s.visited||(m(t,s),s.visited=!0,e--),t=s,r&&await r({grid:this.grid,currentCell:t})}return this.grid}initializeGrid(){this.stack=[],this.grid=Array.from({length:this.height},(t,e)=>Array.from({length:this.width},(r,i)=>({x:i,y:e,walls:{top:!0,right:!0,bottom:!0,left:!0},visited:!1})))}};var w=class{heap=[];insert(t,e){this.heap.push({item:t,priority:e}),this.siftUp(this.heap.length-1)}extractMin(){if(this.isEmpty())return null;this.swap(0,this.heap.length-1);let{item:t}=this.heap.pop();return this.isEmpty()||this.siftDown(0),t}isEmpty(){return this.heap.length===0}getItems(){return this.heap.map(t=>t.item)}getParentIndex(t){return Math.floor((t-1)/2)}getLeftChildIndex(t){return 2*t+1}getRightChildIndex(t){return 2*t+2}swap(t,e){[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]]}siftUp(t){let e=this.getParentIndex(t);for(;t>0&&this.heap[t].priority<this.heap[e].priority;)this.swap(t,e),t=e,e=this.getParentIndex(t)}siftDown(t){let e=t,r=this.getLeftChildIndex(t),i=this.getRightChildIndex(t),s=this.heap.length;r<s&&this.heap[r].priority<this.heap[e].priority&&(e=r),i<s&&this.heap[i].priority<this.heap[e].priority&&(e=i),t!==e&&(this.swap(t,e),this.siftDown(e))}};var C=class{grid;width;height;options;constructor(t,e={}){this.grid=t,this.height=t.length,this.width=this.height>0?t[0].length:0,this.options=e}heuristic(t,e){return Math.abs(t.x-e.x)+Math.abs(t.y-e.y)}async solve(t,e){return this.solveBidirectional(t,e)}async solveBidirectional(t,e){let r=this.grid[t.y][t.x],i=this.grid[e.y][e.x];if(r===i)return[r];let s=this.options.onStep,n=new w,a=new Set,o=new Map,l=new Map;l.set(r,0),n.insert(r,this.heuristic(r,i));let h=new w,d=new Set,v=new Map,M=new Map;M.set(i,0),h.insert(i,this.heuristic(i,r));let f=null;for(;!n.isEmpty()&&!h.isEmpty();){let g=n.extractMin();if(a.has(g))continue;if(a.add(g),d.has(g)){f=g;break}s&&await s({grid:this.grid,openSetForward:n.getItems(),closedSetForward:Array.from(a),openSetBackward:h.getItems(),closedSetBackward:Array.from(d),currentForward:g}),this._expandNeighbors(g,i,l,o,n);let u=h.extractMin();if(!d.has(u)){if(d.add(u),a.has(u)){f=u;break}s&&await s({grid:this.grid,openSetForward:n.getItems(),closedSetForward:Array.from(a),openSetBackward:h.getItems(),closedSetBackward:Array.from(d),currentForward:g,currentBackward:u}),this._expandNeighbors(u,r,M,v,h)}}if(f){let g=this._reconstructPath(o,f),u=this._reconstructPath(v,f);return u.reverse(),s&&await s({grid:this.grid,openSetForward:[],closedSetForward:Array.from(a),openSetBackward:[],closedSetBackward:Array.from(d),meetingNode:f}),g.concat(u.slice(1))}return[]}_expandNeighbors(t,e,r,i,s){let{x:n,y:a,walls:o}=t,l=[];!o.top&&a>0&&l.push(this.grid[a-1][n]),!o.right&&n<this.width-1&&l.push(this.grid[a][n+1]),!o.bottom&&a<this.height-1&&l.push(this.grid[a+1][n]),!o.left&&n>0&&l.push(this.grid[a][n-1]);for(let h of l){let d=(r.get(t)??1/0)+1;if(d<(r.get(h)??1/0)){i.set(h,t),r.set(h,d);let v=d+this.heuristic(h,e);s.insert(h,v)}}}_reconstructPath(t,e){let r=[e],i=e;for(;i=t.get(i);)r.unshift(i);return r}};var p={background:"#FFFFFF",wall:"#333333",path:"#81C784",current:"#FFEB3B",stack:"#90CAF9",activeSet:"#FFCC80",walkPath:"#CE93D8",forwardOpen:"#C8E6C9",forwardClosed:"#FFCDD2",backwardOpen:"#BBDEFB",backwardClosed:"#FFECB3",meetingNode:"#F48FB1"},k=class{ctx;mazeWidth;mazeHeight;cellSize;wallThickness;constructor(t,e,r){this.ctx=t.getContext("2d"),this.mazeWidth=e,this.mazeHeight=r;let i=t.width,s=t.height;this.cellSize=Math.floor(Math.min(i/e,s/r)),this.wallThickness=Math.max(1,Math.floor(this.cellSize/10))}clearCanvas(){this.ctx.fillStyle=p.background,this.ctx.fillRect(0,0,this.mazeWidth*this.cellSize,this.mazeHeight*this.cellSize)}drawCell(t,e){this.ctx.fillStyle=e,this.ctx.fillRect(t.x*this.cellSize,t.y*this.cellSize,this.cellSize,this.cellSize)}drawGrid(t){this.ctx.strokeStyle=p.wall,this.ctx.lineWidth=this.wallThickness,this.ctx.beginPath();for(let e=0;e<this.mazeHeight;e++)for(let r=0;r<this.mazeWidth;r++){let i=t[e][r],s=r*this.cellSize,n=e*this.cellSize;i.walls.top&&(this.ctx.moveTo(s,n),this.ctx.lineTo(s+this.cellSize,n)),i.walls.right&&(this.ctx.moveTo(s+this.cellSize,n),this.ctx.lineTo(s+this.cellSize,n+this.cellSize)),i.walls.bottom&&(this.ctx.moveTo(s+this.cellSize,n+this.cellSize),this.ctx.lineTo(s,n+this.cellSize)),i.walls.left&&(this.ctx.moveTo(s,n+this.cellSize),this.ctx.lineTo(s,n))}this.ctx.stroke()}renderStep(t){this.clearCanvas(),"closedSetForward"in t?(t.closedSetBackward.forEach(e=>this.drawCell(e,p.backwardClosed)),t.closedSetForward.forEach(e=>this.drawCell(e,p.forwardClosed)),t.openSetBackward.forEach(e=>this.drawCell(e,p.backwardOpen)),t.openSetForward.forEach(e=>this.drawCell(e,p.forwardOpen)),t.meetingNode&&this.drawCell(t.meetingNode,p.meetingNode)):(t.activeSet&&t.activeSet.forEach(e=>this.drawCell(e,p.activeSet)),t.stack&&t.stack.forEach(e=>this.drawCell(e,p.stack)),t.walkPath&&t.walkPath.forEach(e=>this.drawCell(e,p.walkPath)),t.currentCell&&this.drawCell(t.currentCell,p.current)),this.drawGrid(t.grid)}drawFinalPath(t,e){this.clearCanvas(),this.drawGrid(t),e.forEach(r=>this.drawCell(r,p.path)),this.drawGrid(t)}resizeCanvas(t){let e=t.parentElement,r=Math.min(e.clientWidth,e.clientHeight);t.width=r,t.height=r,this.cellSize=Math.floor(Math.min(t.width/this.mazeWidth,t.height/this.mazeHeight)),this.wallThickness=Math.max(1,Math.floor(this.cellSize/10))}};var x=class{canvas;drawer=null;currentGrid=null;isAnimating=!1;stopAnimationFlag=!1;algoSelect;widthInput;heightInput;seedInput;delayInput;generateBtn;solveBtn;stopBtn;rbBiasOption;rbBiasInput;gtStrategyOption;gtStrategySelect;btBiasOption;btBiasSelect;constructor(){this.canvas=document.getElementById("maze-canvas"),this.algoSelect=document.getElementById("algo-select"),this.widthInput=document.getElementById("width-input"),this.heightInput=document.getElementById("height-input"),this.seedInput=document.getElementById("seed-input"),this.delayInput=document.getElementById("delay-input"),this.generateBtn=document.getElementById("generate-btn"),this.solveBtn=document.getElementById("solve-btn"),this.stopBtn=document.getElementById("stop-btn"),this.rbBiasOption=document.getElementById("rb-bias-option"),this.rbBiasInput=document.getElementById("rb-bias-input"),this.gtStrategyOption=document.getElementById("gt-strategy-option"),this.gtStrategySelect=document.getElementById("gt-strategy-select"),this.btBiasOption=document.getElementById("bt-bias-option"),this.btBiasSelect=document.getElementById("bt-bias-select"),this.populateSelects(),this.bindEvents()}populateSelects(){["recursive-backtracker","recursive-backtracker-biased","prim","kruskal","wilson","growing-tree","binary-tree","aldous-broder"].forEach(i=>{let s=document.createElement("option");s.value=i,s.textContent=i.split("-").map(n=>n.charAt(0).toUpperCase()+n.slice(1)).join(" "),this.algoSelect.appendChild(s)}),["newest","random","oldest"].forEach(i=>this.gtStrategySelect.add(new Option(i,i))),["north-west","north-east","south-west","south-east"].forEach(i=>this.btBiasSelect.add(new Option(i,i)))}bindEvents(){this.generateBtn.addEventListener("click",()=>this.runGeneration()),this.solveBtn.addEventListener("click",()=>this.runSolver()),this.stopBtn.addEventListener("click",()=>{this.stopAnimationFlag=!0}),this.algoSelect.addEventListener("change",()=>this.toggleOptionsPanel()),window.addEventListener("resize",()=>this.handleResize()),this.toggleOptionsPanel()}toggleOptionsPanel(){let t=this.algoSelect.value;this.rbBiasOption.classList.toggle("hidden",t!=="recursive-backtracker-biased"),this.gtStrategyOption.classList.toggle("hidden",t!=="growing-tree"),this.btBiasOption.classList.toggle("hidden",t!=="binary-tree")}handleResize(){this.drawer&&(this.drawer.resizeCanvas(this.canvas),this.currentGrid&&this.drawer.drawFinalPath(this.currentGrid,[]))}setUiState(t){this.isAnimating=t,this.generateBtn.disabled=t,this.solveBtn.disabled=t||!this.currentGrid,this.stopBtn.disabled=!t}getOptions(){let e={seed:this.seedInput.value?parseInt(this.seedInput.value,10):void 0};switch(this.algoSelect.value){case"recursive-backtracker-biased":e.straightBias=parseFloat(this.rbBiasInput.value);break;case"growing-tree":e.growingTreeStrategy=this.gtStrategySelect.value;break;case"binary-tree":e.binaryTreeBias=this.btBiasSelect.value;break}return e}async runGeneration(){if(this.isAnimating)return;this.setUiState(!0),this.stopAnimationFlag=!1;let t=parseInt(this.widthInput.value,10),e=parseInt(this.heightInput.value,10),r=this.algoSelect.value,i=this.getOptions(),s=parseInt(this.delayInput.value,10);this.drawer=new k(this.canvas,t,e),this.drawer.resizeCanvas(this.canvas);let n=async o=>{if(this.stopAnimationFlag)throw new Error("Animation stopped by user.");this.drawer.renderStep(o),await new Promise(l=>setTimeout(l,s))},a=new y(t,e,r,{...i,onStep:n});try{this.currentGrid=await a.generate(),this.drawer.drawFinalPath(this.currentGrid,[])}catch(o){console.log(o)}finally{this.setUiState(!1)}}async runSolver(){if(this.isAnimating||!this.currentGrid)return;this.setUiState(!0),this.stopAnimationFlag=!1;let t=parseInt(this.delayInput.value,10),e={x:0,y:0},r={x:this.currentGrid[0].length-1,y:this.currentGrid.length-1},i=async n=>{if(this.stopAnimationFlag)throw new Error("Animation stopped by user.");this.drawer.renderStep(n),await new Promise(a=>setTimeout(a,t))},s=new C(this.currentGrid,{onStep:i});try{let n=await s.solve(e,r);this.drawer.drawFinalPath(this.currentGrid,n)}catch(n){console.log(n)}finally{this.setUiState(!1)}}};new x;})();
